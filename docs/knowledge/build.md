# ビルドと Quarkus のビルドモード

## ビルドとは

ソースコード（人間が読める言語）を、コンピュータが実行できる形式に変換するプロセス全体のこと。

Java の場合は通常2段階：

```
ソースコード (.java)
    ↓ javac（コンパイル）
バイトコード (.class / .jar)   ← JVM が解釈できる中間形式
    ↓ JVM（実行時に解釈・JIT コンパイル）
機械語（CPU が直接実行）
```

## JVM モードとネイティブビルドの違い

### JVM モード

バイトコードのまま配布し、JVM の上で動かす。ライブラリはすでにバイトコードで配布されているので再コンパイル不要。JVM ランタイム自体も変換不要。

### ネイティブビルド（GraalVM）

GraalVM の `native-image` ツールで、バイトコードを事前（AOT）に機械語へ変換する。
JVM が不要になるため、起動時のウォームアップ時間がなくなる。

```
バイトコード
    ↓ GraalVM native-image（AOT コンパイル、数分かかる）
ネイティブバイナリ ← JVM 不要、そのまま実行可能
```

GraalVM はビルド時に「アプリ全体＋ライブラリ＋ランタイム代替コード」を静的解析して機械語に変換するため、処理量が膨大でビルドに数分かかる。

## 使い分け

| 場面 | モード | 理由 |
|------|--------|------|
| サーバーレス / FaaS | ネイティブ | コールドスタートが課金・タイムアウトに直結 |
| コンテナを大量スケール | ネイティブ | 起動が速いとスパイクに瞬時対応できる |
| メモリ制約のある環境 | ネイティブ | 常駐メモリが数十 MB 台に収まる |
| 開発中（Dev Mode） | JVM | ネイティブビルドは数分かかるため不向き |
| ユニット・統合テスト | JVM | CI 専用のネイティブテストとは別に高速な JVM テストを使う |
| リフレクションを多用するライブラリ | JVM | AOT との相性問題が発生することがある |
| 長時間動くバッチ処理 | JVM | JIT の実行時最適化が長命プロセスで効いてくる |

## JVM モードのフィードバックループが速い理由

コンパイルする量の違いによる：

| | コンパイル対象 | 所要時間 |
|---|---|---|
| ネイティブビルド | 自分のコード＋全ライブラリ＋ランタイム代替コード | 数分 |
| JVM モード（フルビルド） | 自分のコードのみ | 数秒 |
| JVM モード（Dev Mode 差分） | 変更されたクラスのみ | < 1秒 |

「機械語への変換を実行時の JVM に任せる」ことで、ビルド時の仕事を最小限にしているのが本質。

## Dev Mode のライブリロード

`./mvnw quarkus:dev` で起動すると、ファイルの変更を自動検知してクラスを差し替える。サーバーの再起動は不要。

### 仕組み

OS のファイルシステム変更通知 API（macOS: `FSEvents`、Linux: `inotify`）でソースディレクトリを監視する。
変更検知のタイミングは「保存した瞬間」ではなく「次の HTTP リクエストが来たとき」。

```
ファイル保存 → （この時点では何も起きない）
    ↓
curl でリクエスト → 変更を検知 → 変更クラスのみ再コンパイル → 新しいコードで応答
```

### ネイティブビルドでライブリロードができない理由

ネイティブビルドはコードを機械語に焼き固めているため、クラスの差し替えという概念自体が存在しない。変更を反映するには毎回フルビルドし直す必要がある。

## このプロジェクトの方針

| 場面 | モード | コマンド |
|------|--------|----------|
| 開発中 | JVM（Dev Mode） | `./mvnw quarkus:dev` |
| ユニット・統合テスト | JVM | `./mvnw test` |
| 本番コンテナ | ネイティブ | `./mvnw package -Dnative` → Docker イメージ化 |

`pom.xml` の `native` プロファイルで `quarkus.package.jar.enabled=false` を設定しており、ネイティブビルド時は JVM 用の JAR を生成しない（本番は必ずネイティブバイナリを使うという意思決定）。

また `quarkus.native.container-build=true` により、ローカルに GraalVM をインストールしなくても Docker コンテナ内でネイティブビルドが行える。
